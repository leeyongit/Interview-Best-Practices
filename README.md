# Interview-Notes
> 常见面试题总结

## 认证授权
#### 1. session 工作原理?
浏览器第一次请求网站， 服务端生成 Session ID。
把生成的 Session ID 保存到服务端存储中。
把生成的 Session ID 返回给浏览器，通过 set-cookie。
浏览器收到 Session ID， 在下一次发送请求时就会带上这个 Session ID。
服务端收到浏览器发来的 Session ID，从 Session 存储中找到用户状态数据，会话建立。
此后的请求都会交换这个 Session ID，进行有状态的会话。

## PHP
#### 1. PHP的垃圾回收机制
PHP 可以自动进行内存管理，清除不需要的对象。
PHP 使用了引用计数 (reference counting) GC 机制。
每个对象都内含一个引用计数器 refcount，每个 reference 连接到对象，计数器加 1。当 reference 离开生存空间或被设为 NULL，计数器减 1。当某个对象的引用计数器为零时，PHP 知道你将不再需要使用这个对象，释放其所占的内存空间。

## MySQL
#### 脏读、幻读和不可重复读
在一个程序中，依据事务的隔离级别将会有三种情况发生。
- 脏读：一个事务会读进还没有被另一个事务提交的数据，所以你会看到一些最后被另一个事务回滚掉的数据。
- 不可重复读：一个事务读进一条记录，另一个事务更改了这条记录并提交完毕，这时候第一个事务再次读这条记录时，它已经改变了。
- 幻读：一个事务用Where子句来检索一个表的数据，另一个事务插入一条新的记录，并且符合Where条件，这样，第一个事务用同一个where条件来检索数据后，就会多出一条记录。

## Redis 面试题

#### 1. 为什呢Redis是单线程的呢?
官方回答: 因为Redis是基于内存的,所以CPU不会是Redis的瓶颈,但是内存会是,而且多线程的实现比较麻烦,直接使用单线程更省事一点。因为Redis是直接操作内存的,而且是单线程的,避免了频繁的切换上下文,所以速度非常快。

#### 2. 你的Redis怎么持久化的?
一般我们在生产上采用的持久化策略为:
* master关闭持久化
* slave开RDB即可，必要的时候AOF和RDB都开启
该策略能够适应绝大部分场景，绝大部分集群架构。

(1) master关闭持久化原因很简单，因为无论哪种持久化方式都会影响redis的性能，哪一种持久化都会造成CPU卡顿，影响对客户端请求的处理。为了保证读写最佳性能，将master的持久化关闭！

(2) slave开RDB即可，必要的时候AOF和RDB都开启首先，我先说明一下，我不推荐单开AOF的原因是，基于AOF的数据恢复太慢。 你要想，我们已经做了主从复制，数据已经实现备份，为什么slave还需要开持久化? 因为某一天可能因为某某工程，把机房的电线挖断了，就会导致master和slave机器同时关机。 那么这个时候，我们需要迅速恢复集群，而RDB文件文件小、恢复快，因此灾难恢复常用RDB文件。

[原文](https://zhuanlan.zhihu.com/p/68402040)

## 网络
#### 1. TCP\IP协议和HTTP协议是什么？
TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。

TCP是Tranfer Control Protocol的简称，TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。



## 数据结构与算法
#### 1. 栈和队列的区别是什么？
* 队列先进先出，栈先进后出。
* 对插入和删除操作的"限定"不同。
    - 栈是限定只能在表的一端进行插入和删除操作的线性表。
    - 队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。
* 遍历数据速度不同。
    - 栈只能从头部取数据，也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性。
    - 队列则不同，它基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影响数据结构，速度要快的多

#### 2. 冒泡排序和归并排序的区别是什么？
* 冒泡排序：思想是相邻元素逐个比较，然后将最大的放在后面。每遍历完一次，就会有一个元素就位，所以时间复杂度为O(n^2)
* 归并排序：归并排序是利用分治与递归的思想，先将序列分为多个子序列，然后子序列递归排序，并且归并子序列。

## 推荐教程
* [Zookeeper：分布式系统入门到实战](https://www.youtube.com/watch?v=BhosKsE8up8&list=RDCMUCrTVwxlwmn2CJINfuaiLB1Q&start_radio=1&t=213)
