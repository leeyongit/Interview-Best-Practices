# 数据结构基础
表：数组、链表
树：二叉树、树
图：
## 什么是数据结构
* 结构：实体 + 关系
* 数据结构：(由逻辑、存储、运算来组合的)
    * **按照逻辑关系**组织起来的一批数据
    * 按照一定的 **存储方法**把它存储在计算机中
    * 在这些数据上定义了一个 **运算**的集合

## 数据结构的逻辑组织
* 线性结构
    - 线性表 (表，栈，队列，串等)
* 非线形结构
    - 树 (二叉树，Huffman树，二叉检索树等)
    - 图 (有向图，无向图等)
* 图 >= 树 >= 二叉树 >= 线性表 (包含关系)

## 数据的存储结构
* 逻辑结构到物理存储空间的 **映射**
计算机主存储器（内存）
* **非负整数**地址编码， **相邻单元**的集合
    * 基本单位是字节
    * 访问不同地址所需时间基本相同（即随机访问）
四类：顺序、链接、索引、散列

## 基本算法分类
* 穷举法
* 回溯、搜索
* 递归分治
* 贪心法
* 动态规划

## 线性表
### 线性表概念
* 线性表简称表，是零个或多个元素的有穷序列，通常可以表示成k0, k1, ... k(n-1) (n>=1)
    * 表目(记录)：线性表中的元素(可包含多个数据项，记录)
    * 索引(下标)：i称为表目ki的 "索引" 或 "下标"
    * 表的长度：线性表中所含元素的个数n
    * 空表：长度为零的线性表(n=0)
* 线性表特点：
    * 操作灵活，其长度可以增长、缩短

### 线性结构
- 二元组 B = (K,R) K = {a0,a1,...a(n-1)} R = {r}
    - 有一个唯一的 **开始结点**，它没有前驱，有一个唯一的直接后继
    - 一个唯一的 **终止结点**，它有一个唯一的直接前驱，没有后继
    - 其它的结点皆称为 **内部结点**,每一个内部结点都有且仅有一个唯一的直接前驱，也有一个唯一的直接后继
    - 前驱/后继关系r， 具有 **反对称性** 和 **传递性**
- 特点
    - 均匀性：虽然不同线性表的数据元素可以是各种各样的，但对于同一线性表的各数据元素必定具有 **相同** 的 **数据类型**和 **长度**
    - 有序性：各数据元素在线性表中都有自己的位置，且数据元素之前的 **相对位置**是 **线性**的

- 按复杂度划分
     - 简单的：线性表、栈、队列、散列表
     - 高级的：广义表、多维数组、文件...
- 按访问方式划分
     - 直接访问型 direct access  数组
     - 顺序访问型 sequential access 链表
     - 目录索引型 directory access 字典 散列
- 按操作划分
    - 线性表
        - 所有表目都是同一类型结点的线性表
        - 不限制操作形式
        - 根据存储的不同分为：顺序表，链表
    - 栈 (LIFO, Last In First Out)
        - 插入和删除操作都限制在表的同一端进行
    - 队列 (FIFO, First In First Out)
        - 插入操作在表的一端，删除操作在另一端

三个方面
 - 线性表的逻辑结构
 - 线性表的存储结构
 - 线性表运算

线性表的逻辑结构
 - 主要属性包括
    - 线性表的长度
    - 表头(head)
    - 表尾(tail)
    - 当前位置(current position)

线性表的存储结构
 - 顺序表
    - 按索引值从小到大存放在一片相邻的连线区域
    - 紧凑结构，存储密度为1
 - 链表
    - 单链表
    - 双链表
    - 循环链表

线性表分类 (按操作)
 * 线性表  - 不限制操作
 * 栈     - 在同一端操作
 * 队列   - 在两端操作

线性表的运算
 - 建立线性表
 - 清除线性表
 - 插入一个新元素
 - 删除某个元素
 - 修改某个元素
 - 排序
 - 检索

### 线性表类模版
```c
template <class T> class List {
    void clear();   // 置空线性表
    bool isEmpty(); // 线性表为空时，返回true
    bool append(const T value); // 在表尾添加一个元素value, 表的长度增1
    bool insert(const int p, const T value); // 在位置p上插入一个元素value,表的长度增1
    bool delete(const int p); // 删除位置p上的元素，表的长度减1
    bool getPos(int& p, const T value); // 查找值为value的元素并返回其位置
    bool getValue(const int p, T& value); // 把位置p元素值返回到变量value
    bool setValue(const int p, const T value); // 用value修改位置p的元素值
}
```
